AICs <- sapply(families_thermalC, function(x) {
AIC(gamlss(Thermal.C~ Elevation + Temp + M.C,
data = alex_data, family = x))
})
knitr::kable(data.frame(Distribution = families_thermalC, AICs = AICs))
?knitr::kable
View(alex_data)
alex_data <- alex_data %>% dplyr::mutate(Id = case_when(
latitude < 7.4525 ~ 1,
latitude >= 7.4525 & latitude <= 7.475 ~ 2,
latitude > 7.475 ~ 3
), M.C_logit = psych::logit(M.C) ) %>% dplyr::mutate(Id2 = as.factor(Id))
alex_data %>% ggplot(data = ., aes(x = Longitude, y = latitude,
color = Id2)) +
geom_point(size = 2) + theme_bw() + labs(color = "Cluster_Id")
View(alex_data)
AIC(gamlss(psych::logit(Thermal.D) ~ Elevation + Temp + M.C,
data = alex_data[-17, ], family = NO))
AIC(gamlss(psych::logit(Thermal.D) ~ Elevation + Temp + M.C,
data = alex_data[, ], family = NO))
psych::logt(1)
psych::logit(1)
log(1)
log(0.82)
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(tidyverse)
library(ggmap)
library(CAMAN)
library(rjags)
library(runjags)
library(gamlss)
library(psych)
alex_data <- read_csv("Data/data.csv", col_names = T)
#names(alex_data)
lat <- 7.451099
lon <- 3.896599
ggplot(data = alex_data, aes(x = Longitude, y = latitude)) +
geom_point(size = 2) + theme_bw() + geom_jitter(width = 0.60) +
labs(x = "Longitude", y = "Latitude")
alex_data <- alex_data %>% dplyr::mutate(Id = case_when(
latitude < 7.4525 ~ 1,
latitude >= 7.4525 & latitude <= 7.475 ~ 2,
latitude > 7.475 ~ 3
), M.C_logit = psych::logit(M.C) ) %>% dplyr::mutate(Id2 = as.factor(Id))
alex_data %>% ggplot(data = ., aes(x = Longitude, y = latitude,
color = Id2)) +
geom_point(size = 2) + theme_bw() + labs(color = "Cluster_Id")
families_thermalC <- c("NO", "GA", "LOGNO", "IGAMMA")
AICs <- sapply(families_thermalC, function(x) {
AIC(gamlss(Thermal.C~ Elevation + Temp + M.C,
data = alex_data, family = x))
})
knitr::kable(data.frame(Distribution = families_thermalC, AICs = AICs),
row.names = F, align = 'c')
families_S.H <- c("NO", "GA", "LOGNO", "IGAMMA")
AICs <- sapply(families_S.H, function(x) {
AIC(gamlss(S.H~ Elevation + Temp + M.C,
data = alex_data, family = x))
})
knitr::kable(data.frame(Distribution = families_S.H, AICs = AICs),
row.names = F, align = 'c')
families_thermalD <- c("NO", "GA", "LOGNO", "IGAMMA")
AICs <- sapply(families_thermalD, function(x) {
AIC(gamlss(Thermal.D~ Elevation + Temp + M.C,
data = alex_data, family = x))
})
knitr::kable(data.frame(Distribution = families_thermalD, AICs = AICs),
row.names = F, align = 'c')
alex_data1 <- alex_data[-17, ]
aic_beta <- AIC(gamlss(Thermal.D~ Elevation + Temp + M.C,
data = alex_data1, family = BE))
#alex_data1=alex_data[-17,] # This is not needed since it has been defined above
Thermal.D_logit <- psych::logit(alex_data1$Thermal.D)
aic_logitnorm <- AIC(gamlss(Thermal.D_logit~ Elevation + Temp + M.C,
data = alex_data1, family = NO))
knitr::kable(data.frame(Distributions = c("NO", "Beta"),
AICs = c(aic_logitnorm, aic_beta)),
row.names = F, align = 'c')
-27.42912 + 32.4279
logLik(gamlss(Thermal.D~ Elevation + Temp + M.C,
data = alex_data1, family = BE))
logLik(gamlss(Thermal.D~ Elevation + Temp + M.C,
data = alex_data, family = NO))
aic_norm <- AIC(gamlss(Thermal.D ~ Elevation + Temp + M.C,
data = alex_data1, family = NO))
knitr::kable(data.frame(Distributions = c("NO", "NO[-17]", "Beta"),
AICs = c(aic_logitnorm, aic_norm, aic_beta)),
row.names = F, align = 'c')
-27.42 + 29.40
logLik(gamlss(Thermal.D ~ Elevation + Temp + M.C,
data = alex_data1, family = NO))
logLik(gamlss(Thermal.D ~ Elevation + Temp + M.C,
data = alex_data1, family = BE))
logLik(gamlss(Thermal.D ~ Elevation + Temp + M.C,
data = alex_data, family = NO))
19.70062 - 18.71456
cat("
model{
#### #the normal likelihood for the data
for(i in 1: N) {
mu[i] <-  beta[1] + beta[2]*Elevation[i] + beta[3]*Temp[i] + beta[4]*MC[i]
y[i] ~ dnorm(mu[i], tau)
res[i] <- y[i]-mu[i]
}
#priors for the population parameters
#variance
tau <- pow(sigma_y, -2) #converting a precision
sigma_y ~ dunif(0, 20) #sampling a standard deviation
#prior for the betas
for(i in 1:4) {
beta[i] ~ dnorm(0.0, 1.0E-5)
}
#I don't understand this line.
##You already have the residuals in res????
#fit=(res[])
}",
file = "ThermalC_bayesian.bug")
thermalCdata <- list(N = nrow(alex_data),
y = alex_data$Thermal.C,
Elevation = alex_data$Elevation,
Temp = alex_data$Temp,
MC = alex_data$M.C
)
thermalCini <- list(list(beta = c(0.9, 0.002, 0.03, 1.59), sigma_y = 0.12),
list(beta = c(0.9, 0.002, 0.03, 1.59)/2, sigma_y = 0.12/2))
thermalC_bayesian <- run.jags(model = "ThermalC_bayesian.bug",
monitor=c("beta", "sigma_y","res"),
data = thermalCdata, inits = thermalCini, n.chains = 2,
sample = 30000, burnin = 20000,
thin = 15, adapt = 40000,
method = "rjags", jags.refresh = 10)
knitr::kable(thermalC_bayesian$summaries)
knitr::kable(thermalC_bayesian$summaries[, c(1:5)])
knitr::kable(thermalC_bayesian$summaries[1:5, c(1:5)])
plot(thermalC_bayesian, "trace")
?plot.runjags
plot(thermalC_bayesian, "trace", vars = c("beta", "sigma_y"))
plot(thermalC_bayesian, "autocorr", vars = c("beta", "sigma_y"))
alex_data <- alex_data[order(alex_data$Id),]
#normal assumption for thermal C
cat("
model{
#### #the normal likelihood for the data
for(i in 1: N){
#you didn't add the random effect b[Id[i]]
mu[i] <-  beta[2]*Elevation[i] + beta[3]*Temp[i] + beta[4]*MC[i] +
b[Id[i]]
y[i] ~ dnorm(mu[i], tau)
res[i] <- y[i]-mu[i]
}
#the cluster random effects
for(j in 1:J){
b[j] ~ dnorm(beta[1], tau.b)
}
#priors for the population parameters
#variance
tau <- pow(sigma_y, -2) #converting a precision
sigma_y ~ dunif(0, 20) #sampling a standard deviation
#priors for the population parameters
#prior for the betas
for(i in 1:4){
beta[i] ~ dnorm(0.0, 1.0E-5)
}
#prior for the random effect parameters
#variance between clusters
tau.b <- pow(sigma.b, -2) #converting it to a precision
sigma.b ~ dunif(0, 20) #sampling a standard deviation
###Intra cluster correlation
#cluster1
icc <- sigma.b / (sigma.b + sigma_y)
######fit resiuals########### not needed again
#fit=res[]
}", file =  "ThermalC_bayesian.bug")
thermalCdata <- list(N = nrow(alex_data),
Id = alex_data$Id,
y = alex_data$Thermal.C,
Elevation = alex_data$Elevation,
Temp = alex_data$Temp,
MC = alex_data$M.C,
J = length(unique(alex_data$Id))
)
thermalCini <- list(list(beta = c(0.9, 0.002, 0.03, 1.59), sigma_y=0.12,
sigma.b = 0.12),
list(beta = c(0.9, 0.002, 0.03, 1.59)/2, sigma_y=0.12/2,
sigma.b = 0.12/2))
thermalC_bayesian <- run.jags(model =  "ThermalC_bayesian.bug",
monitor=c("beta", "sigma_y", "sigma.b","res", "icc"),
data = thermalCdata, inits = thermalCini,
n.chains = 2,
sample = 50000, burnin = 50000,
thin = 15, adapt = 40000,
method = "rjags", jags.refresh = 10)
45/7
45 %% 7
## Spatial Model
### Variogram for Thermal C Based on Bayesian-Linear Regression Model
thermalC_res <- thermalC_bayesian_noclust$summaries[str_detect(row.names(thermalC_bayesian_noclust$summaries), "res"), "Mean"]
thermalC_gdata <- as.geodata(cbind(alex_data$Longitude, alex_data$latitude, thermalC_res))
### varogram across all clusters (we can just keep this)
dd_matrix <- as.matrix(dist(alex_data[, 2:3], diag = T, upper = T))
vvs_thermalC <- variog(thermalC_gdata, uvec = quantile(unique(as.numeric(dd_matrix)), seq(0, 1, 0.01)), option = "bin")
plot(vvs_thermalC, type="p", pch=19, col = 2,cex.lab = 1.3,
main = "",
ylab = expression(v(u)), lwd = 2 )
### Thermal.C
cat("
model{
#### prior for the variogram model
phi ~ dunif(0, 10)
tetha1 ~ dunif(0, 10) #sill
tetha12 ~ dunif(0, 20) #standard deviation tau
tau2 <- pow(tetha12, -2) #precision = 1/tau2
#semi-variogram model (defining the likelihood of the semi-variogram model)
for(k in 1 : N2){
mu_v[k] <- tetha1 * (1 - exp(- u[k] / phi))
vu[k] ~ dnorm(mu_v[k], tau2)
}
#sampling s(x) from the variogram model
for(i in 1: N){
mu_vnew[i] <- tetha1 * (1 - exp(- uvec[i] / phi))
sx[i] ~ dnorm(mu_vnew[i], tau2)
}
#### #the normal likelihood for the data
for(i in 1: N) {
mu[i] <-  beta[2]*Elevation[i] + beta[3]*Temp[i] + beta[4]*MC[i] + sx[i]
y[i] ~ dnorm(mu[i], tau)
}
#priors for the population parameters
#variance
tau <- pow(sigma_y, -2) #converting a precision
sigma_y ~ dunif(0, 20) #sampling a standard deviation
#priors for the population parameters
#prior for the betas
for(i in 1:4) {
beta[i] ~ dnorm(0.0, 1.0E-5)
}
}",
file = "thermal_spbayesian.bug")
thermalCdata <- list(N = nrow(alex_data),
y = alex_data$Thermal.C,
u = vvs_thermalC$u,
vu = vvs_thermalC$v,
uvec = vvs_thermalC$uvec,
N2 = length(vvs_thermalC$u),
Elevation = alex_data$Elevation,
Temp = alex_data$Temp,
MC = alex_data$M.C
)
thermalCini <- list(list(beta = c(0.9, 0.002, 0.03, 1.59), sigma_y=0.12,
tetha1 = 0.5, phi = 1.0, tetha12 = 1.23),
list(beta = c(0.9, 0.002, 0.03, 1.59)/2, sigma_y=0.12/2,
tetha1 = 0.5/2, phi = 1.0/2, tetha12 = 1.23/2)
)
thermalC_bayesian_sp <- run.jags(model =  "thermal_spbayesian.bug",
monitor=c("beta", "sigma_y", "tetha1", "tetha12", "phi"),
data = thermalCdata, inits = thermalCini,
n.chains = 2,
sample = 50000, burnin = 50000,
thin = 15, adapt = 40000,
method = "rjags", jags.refresh = 10)
plot(thermalC_bayesian_sp, "trace", vars = c("beta", "sigma_y""tetha1", "tetha12", "phi")
plot(thermalC_bayesian_sp, "autocorr", vars = c("beta", "sigma_y","tetha1", "tetha12", "phi")
dic_thermalC_sp <- extract(thermalC_bayesian_sp, what = "dic")
dic_thermalC_sp
## Spatial-Cluster Model
### Variogram for Thermal C Based on Clustered-Data Model
thermalC_res <- thermalC_bayesian_clust$summaries[str_detect(row.names(thermalC_bayesian_clust$summaries), "res"), "Mean"]
thermalC_gdata <- as.geodata(cbind(alex_data$Longitude, alex_data$latitude, thermalC_res))
### varogram across all clusters (we can just keep this)
dd_matrix <- as.matrix(dist(alex_data[, 2:3], diag = T, upper = T))
vvs_thermalC <- variog(thermalC_gdata, uvec = quantile(unique(as.numeric(dd_matrix)), seq(0, 1, 0.01)), option = "bin")
plot(vvs_thermalC, type="p", pch=19, col = 2,cex.lab = 1.3,
main = "",
ylab = expression(v(u)), lwd = 2 )
#Alex Analysis
library(readr)
library(tidyverse)
library(ggmap)
library(CAMAN)
library(rjags)
library(runjags)
library(gamlss)
library(ggmap)
library(ggplot2)
library(psych)
library(geoR)
library(ggmap)
setwd("C:/Users/user/Documents/kas/sp")
alex_data<-read.csv("data.csv",header = T)
names(alex_data)
lat <- 7.451099
lon <- 3.896599
alex_data <- alex_data %>% dplyr::mutate(Id = case_when(
latitude < 7.4525 ~ 1,
(latitude >= 7.4525 & latitude <= 7.475) & (Longitude > 3.8925) ~ 2,
(latitude >= 7.4525 & latitude <= 7.475) & (Longitude < 3.8925 & Longitude > 3.89) ~ 3,
latitude > 7.475 ~ 4,
Longitude <= 3.89 ~ 5
), M.C_logit = psych::logit(M.C) ) %>% dplyr::mutate(Id2 = as.factor(Id))
alex_data2=alex_data[!alex_data$id%in%c(4,5),]
alex_data2
alex_data2=alex_data[!alex_data$Id%in%c(4,5),]
alex_data2
#normal assumption for thermal C
cat("
model{
#### #the normal likelihood for the data
for(i in 1: N){
mu[i] <-  beta[2]*Elevation[i] + beta[3]*Temp[i] + beta[4]*MC[i] +
b[Id[i]]
y[i] ~ dnorm(mu[i], tau)
res[i] <- y[i] - mu[i]
}
#the cluster random effects
for(j in 1:J) {
b[j] ~ dnorm(beta[1], tau.b)
}
#priors for the population parameters
#variance
tau <- pow(sigma_y, -2) #converting a precision
sigma_y ~ dunif(0, 20) #sampling a standard deviation
#priors for the population parameters
#prior for the betas
for(i in 1:4) {
beta[i] ~ dnorm(0.0, 1.0E-5)
}
#prior for the random effect parameters
#variance between clusters
tau.b <- pow(sigma.b, -2) #converting it to a precision
sigma.b ~ dunif(0, 20) #sampling a standard deviation
###Intra cluster correlation
icc <- sigma.b / (sigma.b + sigma_y)
}", file =  "ThermalC_bayesian.bug")
thermalCdata <- list(N = nrow(alex_data2),
Id = alex_data2$Id,
y = alex_data2$Thermal.C,
Elevation = alex_data2$Elevation,
Temp = alex_data2$Temp,
MC = alex_data2$M.C,
J = length(unique(alex_data2$Id))
)
thermalCini <- list(list(beta = c(0.9, 0.002, 0.03, 1.59), sigma_y=0.12,
sigma.b = 0.12),
list(beta = c(0.9, 0.002, 0.03, 1.59)/2, sigma_y=0.12/2,
sigma.b = 0.12/2))
thermalC3_bayesian_clust <- run.jags(model =  "ThermalC_bayesian.bug",
monitor=c("beta", "sigma_y", "sigma.b","icc","res"),
data = thermalCdata, inits = thermalCini,
n.chains = 2,
sample = 50000, burnin = 50000,
thin = 15, adapt = 40000,
method = "rjags", jags.refresh = 10)
#Alex Analysis
library(readr)
library(tidyverse)
library(ggmap)
library(CAMAN)
library(rjags)
library(runjags)
library(gamlss)
library(ggmap)
library(ggplot2)
library(psych)
library(geoR)
library(ggmap)
setwd("C:/Users/user/Documents/kas/sp")
alex_data<-read.csv("data.csv",header = T)
names(alex_data)
lat <- 7.451099
lon <- 3.896599
alex_data <- alex_data %>% dplyr::mutate(Id = case_when(
latitude < 7.4525 ~ 1,
(latitude >= 7.4525 & latitude <= 7.475) & (Longitude > 3.8925) ~ 2,
(latitude >= 7.4525 & latitude <= 7.475) & (Longitude < 3.8925 & Longitude > 3.89) ~ 3,
latitude > 7.475 ~ 4,
Longitude <= 3.89 ~ 5
), M.C_logit = psych::logit(M.C) ) %>% dplyr::mutate(Id2 = as.factor(Id))
alex_data2=alex_data[!alex_data$Id%in%c(4,5),]
#Bayesian random effect model for Thermal C (spatial correlation treated via accounting for clustering)
#normal assumption for thermal C
cat("
model{
#### #the normal likelihood for the data
for(i in 1: N){
mu[i] <-  beta[2]*Elevation[i] + beta[3]*Temp[i] + beta[4]*MC[i] +
b[Id[i]]
y[i] ~ dnorm(mu[i], tau)
res[i] <- y[i] - mu[i]
}
#the cluster random effects
for(j in 1:J) {
b[j] ~ dnorm(beta[1], tau.b)
}
#priors for the population parameters
#variance
tau <- pow(sigma_y, -2) #converting a precision
sigma_y ~ dunif(0, 20) #sampling a standard deviation
#priors for the population parameters
#prior for the betas
for(i in 1:4) {
beta[i] ~ dnorm(0.0, 1.0E-5)
}
#prior for the random effect parameters
#variance between clusters
tau.b <- pow(sigma.b, -2) #converting it to a precision
sigma.b ~ dunif(0, 20) #sampling a standard deviation
###Intra cluster correlation
icc <- sigma.b / (sigma.b + sigma_y)
}", file =  "ThermalC_bayesian.bug")
thermalCdata <- list(N = nrow(alex_data2),
Id = alex_data2$Id,
y = alex_data2$Thermal.C,
Elevation = alex_data2$Elevation,
Temp = alex_data2$Temp,
MC = alex_data2$M.C,
J = length(unique(alex_data2$Id))
)
thermalCini <- list(list(beta = c(0.9, 0.002, 0.03, 1.59), sigma_y=0.12,
sigma.b = 0.12),
list(beta = c(0.9, 0.002, 0.03, 1.59)/2, sigma_y=0.12/2,
sigma.b = 0.12/2))
thermalC3_bayesian_clust <- run.jags(model =  "ThermalC_bayesian.bug",
monitor=c("beta", "sigma_y", "sigma.b","icc","res"),
data = thermalCdata, inits = thermalCini,
n.chains = 2,
sample = 50000, burnin = 50000,
thin = 15, adapt = 40000,
method = "rjags", jags.refresh = 10)
thermalC_res <- thermalC3_bayesian_clust$summaries[str_detect(row.names(thermalC3_bayesian_clust$summaries), "res"), "Mean"]
thermalC_gdata <- as.geodata(cbind(alex_data2$Longitude, alex_data2$latitude, thermalC_res))
### varogram across all clusters (we can just keep this)
dd_matrix <- as.matrix(dist(alex_data[, 2:3], diag = T, upper = T))
vvs_thermalC <- variog(thermalC_gdata, uvec = quantile(unique(as.numeric(dd_matrix)), seq(0, 1, 0.01)), option = "bin")
plot(vvs_thermalC, type="p", pch=19, col = 2,cex.lab = 1.3,
main = "",
ylab = expression(v(u)), lwd = 2 )
cat("
model{
#### prior for the variogram model
phi ~ dunif(0, 10)
tetha1 ~ dunif(0, 10) #sill
tetha12 ~ dunif(0, 20) #standard deviation tau
tau2 <- pow(tetha12, -2) #precision = 1/tau2
#semi-variogram model (defining the likelihood of the semi-variogram model)
for(k in 1 : N2){
mu_v[k] <- tetha1 * (1 - exp(- u[k] / phi))
vu[k] ~ dnorm(mu_v[k], tau2)
}
#sampling s(x) from the variogram model
for(i in 1: N){
mu_vnew[i] <- tetha1 * (1 - exp(- uvec[i] / phi))
sx[i] ~ dnorm(mu_vnew[i], tau2)
}
#### #the normal likelihood for the data
for(i in 1: N){
#you didn't add the random effect b[Id[i]]
mu[i] <-  beta[2]*Elevation[i] + beta[3]*Temp[i] + beta[4]*MC[i] +
b[Id[i]] + sx[i]
y[i] ~ dnorm(mu[i], tau)
res[i] <- y[i] - mu[i]
}
#the cluster random effects
for(j in 1:J) {
b[j] ~ dnorm(beta[1], tau.b)
}
#priors for the population parameters
#variance
tau <- pow(sigma_y, -2) #converting a precision
sigma_y ~ dunif(0, 20) #sampling a standard deviation
#priors for the population parameters
#prior for the betas
for(i in 1:4) {
beta[i] ~ dnorm(0.0, 1.0E-5)
}
#prior for the random effect parameters
#variance between clusters
tau.b <- pow(sigma.b, -2) #converting it to a precision
sigma.b ~ dunif(0, 20) #sampling a standard deviation
###Intra cluster correlation
icc <- sigma.b / (sigma.b + sigma_y)
#ratio of variotion due to cluster and that due to spatial correlation
sp_clus <- tetha12 / sigma.b
}",
file = "thermal_spclustbayesian.bug")
thermalCdata <- list(N = nrow(alex_data2),
Id = alex_data2$Id,
y = alex_data2$Thermal.C,
u = vvs_thermalC$u,
vu = vvs_thermalC$v,
uvec = vvs_thermalC$uvec,
N2 = length(vvs_thermalC$u),
Elevation = alex_data2$Elevation,
Temp = alex_data2$Temp,
MC = alex_data2$M.C,
J = length(unique(alex_data2$Id))
)
thermalCini <- list(list(beta = c(0.9, 0.002, 0.03, 1.59), sigma_y=0.12,
sigma.b = 0.12, tetha1 = 0.5, phi = 1.0, tetha12 = 1.23),
list(beta = c(0.9, 0.002, 0.03, 1.59)/2, sigma_y=0.12/2,
sigma.b = 0.12/2 , tetha1 = 0.5/2, phi = 1.0/2, tetha12 = 1.23/2)
)
thermalC2_bayesian_spclust <- run.jags(model =  "thermal_spclustbayesian.bug",
monitor=c("beta", "sigma_y", "sigma.b","icc","tetha1", "tetha12", "phi", "sp_clus"),
data = thermalCdata, inits = thermalCini,
n.chains = 2,
sample = 50000, burnin = 50000,
thin = 15, adapt = 40000,
method = "rjags", jags.refresh = 10)
dic_thermalC2_spclust <- extract(thermalC2_bayesian_spclust, what = "dic")
dic_thermalC2_spclust
thermalC2_bayesian_spclust
